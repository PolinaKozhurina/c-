#include <iostream>

class FIFO
{
private:
    int *front;                                        //указатель на самый первый элемент списка
    int *back;                                         //указатель на последний добавленный элемент списка

public:
    FIFO() : front(NULL), back(NULL) {}                 //конструктор используется для инициализации указателей направлением на нулевые адреса

    ~FIFO() {                                           //деструктор, используется для автоматической зачистки памяти в момент прекращения работы класса
        while (front != NULL)                           //с помощью цикла вызываем функцию-член класса, освобождающую занятую элементом списка память
            pop();                                      //вызов функции-члена класса
    }

    void push(int _value) {                            //функция добавления в список элемента
        int *newNode = new int(_value);               //выделение памяти для нового элемента

        if (front == NULL){                              //если элемент первый
            front = newNode;                            //направляем указатель front на него
        }
        else {
            back->next = newNode;                       //в противном случае направляем указатель back->next  на созданный узел
        }

        back = newNode;                                 //и обозначаем, что созданный узел — это последний, хвостовой, элемент списка
    }

    void pop() {
        //   if (front == NULL)           throw std::underflow_error("Nothing to dequeue");

        if (front == NULL) {            //Это упрощённая запись того, что вы видите в закомментированной выше строчке, то обработка путём
            //выброса исключения, но мы скорее всего плохо понимаем, что это, поэтому так
            //здесь можно вставить информационное сообщение о том, что список пустой//
            return;
        }

        //Если список не пустой, то делаем организацию fifo
        int *temp   = front;                           //Объявляем себе указатель и направляем его на начало списка

        front = front->next;                            //Смещаем указатель на начало списка на следующий элемент
        delete temp;                                    //Высвобождаем память от элемента, который стал уже бывшим первым
    }

    /*ФУНКЦИЯ-ЧЛЕН, ВЫВОД ДАННЫХ СПИСКА НА ЭКРАН*/
    void print(){
        int *temp = front;                             //Объявляем себе указатель и направляем его на начало списка
        while (temp != NULL){                          //С помощью цикла обходим весь список
            std::cout << temp->value << ' ';            //Выводим информацию на экран
            temp = temp->next;                          //Направляем указатель на следующий элемент
        }
    }
};

int main(){
    FIFO f1;
    f1.print();
}